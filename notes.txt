---------------------------------------Notes on C programming----------------------------------------

**Developed by Dennis Ritchie in AT&T bell labsh
*Why C
	> programmers have nearly full control
	> fast programming language
	> can manage memory
	> can reach closest to machine level code
	> lowest level programming(above assembly)
	> use for competitive programming
	> first step in learning coding

*Implementation
	> OS like linux and windows macs are designed in C
	> databases and dbms are also designed in c
	> cython, ruby, pearl language is designed in c
	> compilers are also written in c
	> games are designed in c for fast performance
	> python lib are also written in c
	> apache nginx web servers have c in it

*Preprocessing
	removing comments, expanding macros, pasting header files

	>Preprocessing cmd
		preprocessing cmd starts with #
		eg: #include,#define,#undef,#ifdenew contentf,#else,#elif,#pragma
	
	>Header files
		-Two ways to include header files
			#include<stdio.h> -->finds header file in system folder
			#include"file_name" -->finds in the current directory

	stdio.h --> for input output fucntions
	string.h --> for string functions
	stdlib.h --> for dynamic memory allocation functions
	time.h --> time functions
	unistd.h --> unix standard library

	>Predefined macros
		__TIME__ -->returns time as string
		__DATE__ -->returns date as string
		__FILE__ -->returns file name as string
		__STDC__ -->returns 1 if compilers is compiled with ansi standard
		__LINE__ -->returns current line no
	>NULL
	It is a macro defined as (void*)0

*Defining macro
	#define SQUARE(x) x*x
	#define PI 3.14
	
*Compilation Process
	linux terminal command:
	gcc -Wall -save-temps hello.c -o raquib

	1. Preprocessing
		removing comments, expanding macros, pasting header files
		input: hello.c
		output: hello.i

	2. Compilation
		Assembly level Instructions are generated
		input: hello.i
		output: hello.s(assembly file)
	
	3. Assembly
		machine level code is generated
		input: hello.s(assembly file)
		output: hello.o or hello.exe (executable file)

	4. Linking
		combines all files into one executable files

*variables
	1. can have alphabets, numbers and underscore
	2. cant start with numbers
	3. cant have reserved keywords
	4. case sensitive

*global variables: variable declared globally, and have the global scope
	global var initialised to zero, if not mentioned

*local variables: variable declared locally, and have the local scope
*precedence of local var > precedence of global var

*constant
	1. declaring constant using preprocessing command
		#define PI 3.14
	2. declaring constant using const keyword
		const float g = 9.807;

*Data Types
	1. Primitive data types
		int, char, float, double
	2. Derived data types:
		array, pointer, structure and union
	3. enumeration
	4. void

*Following are the primitive data types in C and their size according to 64-bit architecture
	>signed int
	 Format Specifier: %d
	 Size: 32bit

	>unsigned int
	 Format Specifier: %u
	 Size: 32bit

	>signed short int
	 Format Specifier: %hd
	 Size: 16bit

	>unsigned short int
	 Format Specifier: %hu
	 Size: 16bit

	>signed long int
	 Format Specifier: %ld
	 Size: 64bit

	>unsigned long int
	 Format Specifier: %lu
	 Size: 64bit

	>signed char
	 Format Specifier: %c
	 Size: 8bit

	>unsigned char
	 Format Specifier: %c
	 Size: 8bit

	>float
	 Format Specifier: %a.bf
	 Size: 32bit

	>double
	 Format Specifier: %lf
	 Size: 64bit

	>long double
	 Format Specifier: %Lf
	 Size: 128bit

	 >string
	 3+
	 Format Specifier: %s
	 Size: 16bit

*Operators
	1. Arithmetic Opearators
		addition, subtraction, multiplication, division, modulus
	
	2. Relational Opearator
		==, !=, >, <, >=, <=

	3. Updation Operators
		a++, a--, ++a, --a

	4. Assignment Operators
	
	5. Logical Opearator
		&&, ||, !
	
	6. Bitwise Opearator
		&(and), |(or), ^(exclusive or), ~(compliment), <<(left shift), >>(right shift)
	
	7. Miscellanous Opearator
		sizeof, ternery, &, pointer

*Escape Sequences
	1. \a for alarm sound
	2. \b for backspace
	3. \n for new line
	4. \f for form feed
	5. \r for carriage return
	6. \t for horizontal tab
	7. \v for vertical tab
	8. \\ for backslash 
	9. \' for single quote
	10. \" for double quote
	11. \? for question mark
	12. \nnn for octal number
	13. \xhh for hex number

*if else
	1. only if
		if(condition){
			code to be executed
		}

	2. if and else
		if(condition){
			code to be executed
		}
		else{
			code to be executed
		}

	3. if else ladder
		if(condition){
			code to be executed
		}
		else if(condition){
			code to be executed
		}
		else{
			code to be executed
		}

*switch case
	switch can only accept int and char

	switch(variable){
		case 1:
		code;

		case 'a':
		code;

		case 2:
		case 3:
		code for 2 and 3;

		default:
		code of not matching case;
	}
	
*loops
	Types of Loops:
		1. For loop:
			properties:
			1. can have more than 1 initialization like for(i=0;j=0;i<5;i++)
			2. initialization is optional like for(;i<5;i++)
			3. conditional part is also optional like for(i=0;;i++)
			4. can have more than one condition, but other conditions will be treated as statements
			5. can have more than one updation and it is also optional
		2. Do while loop
		3. while loop

*break and continue:
	break: breaks the loop or case and jumps to next block of code
	continue: breaks the current loop and jumps to next iteration

*go to statement
	goto label;

	label: 
	//lines of codes

*Typecasting
	int a = 11;
	int b = 5;
	float result = (float)a/b

*functions
	>declaration
		datatype function(parameter1, parameter2, ...){
			code here
		}

	>Calling
		function(argument1, argument2, ...);

*Recursion / recursive function
	function that calls itself

*arrays
	collection of data items having same data types
		1. one dimensional array (ika list)
			int arr[] = {1, 2, 3, 4};

		2. two dimensional array (ika matrices)
			int arr[2][4]={{2,4,6,8},{5,10,15,20}};

*pointers
	stores the address of another variable
	can be dereference with *
	**NULL pointer is a pointer pointing to nothing
	**void pointer is a pointer having void data type
	**Wild pointer is an uninitialised pointer, pointing to unknown memory space
	**dangling pointer pointing to the memory, which is no longer alive

*pointer Arithmetic
	1. pntr++
	2. pntr--
	3. pntr+n
	4. pntr-n
	5. pntr[n]

*array pointer
	int arr[] = {1,2,4};
	here arr is a array pointer pointing towards first element of an array
	this pointer is a constant pointer, u cant modify it



*dereference method of an array
	> method to get value
		arr[3];
		*(arr+3)
		*(&arr[3])
	> methods to get address
		arr+3
		&arr[3]

*function calls
	we can call function in two ways
		1. call by value
			func(a);
			changes to 'a' in func will not reflect in main funcion
		2. call by reference
			func(&a)
			changes to 'a' in func will get reflect in main function

*passing arrays in function
	1. first way
		main{
		func(arr);
		here we pass the address of first element of an arr in func
		}

		int func(int array[]){
			here we created anothere array having same address as arr in main
			array[3] = 67;
			changes like this will get reflected in main
		}
	
	2. second way
		main{
			func(arr);
		}

		func(int* pntr){
			here we stored the address of the first element of arr in pntr
			*(pntr+3)= 67;
			changes like this will get reflected in the main function

		}

*Strings
	1.Declaring Strings
		a. char name[] = "raquib";
		b. char name[] = {'r','a','q','u','i','b','\0'};
		c. char name[10];	fgets(name,10,stdin);
	
	2.Printing Strings
		a. printf("%s",name);
		b. custom function using while loop
		c. puts(name)

	3. Strings function
		a. strcmp: string compare
		b. strlen: string length
		c. strcat: string concatenation
		d. strcpy: string copy

*Structure
	user defined data type
	syntax: 
		struct [structure_name]{
			datatype1;
			datatype2;
			datatype3;
		}
		[sturcture_variables];

				OR

		struct [structure_name]{
			datatype1;
			datatype2;
			datatype3;
		};
		struct [structure_name] [variables];
	
	defining struct:
		struct employee e1;
		e1.id = 2345;
		e1.name = "raquib";

	sturcture member operator (.)

*Typedef
	    syntax: typedef <old-name> <new-name>
	method 1:
		typedef struct worker{
	    	int id;
	    	int wages;
		}wrkr;

	method 2
		typedef struct worker wrkr;
*union
	very similar to struct, but u can use one data at a time
	all data stored in one sharing location having size equal to largest data size
	syntax similar to struct, use 'union' instead 'struct'

*enumeration
	enum color{
		RED,
		WHITE,
		GREEN
	};
	//we can initialise as RED=7,

*static variable:
	variable that preserve its value even if they are out of their scope and not initialized again
	It gets stored in static segment instead of stack segment
	it remains in memory througout the run of program
	static variables are initialized to zero if not mentioned
	static var can only have constant rvalue
	syntax: 
		static int a = 6;

*Memory Model
	 ___________
	|	Heap	| --> stores data dynamically
	|___________|
	|	Stack	| --> stores data in stack (LIFO) form
	|___________|
	|  Global   | --> global and static variables are stored before code run
	|	And		| 	   ___________________________________________________________________
	|Static var | --> |  data (stores initialised var) |  bss (stores uninitialised var)  |
	|___________|	  |________________________________|__________________________________|
	|    Code   |
	|___________| --> aka text segment. stores text

*dynamic memory allocation
	dynamic memory allocation is a way to allocate and free memory during run time.

	dynamic memory allocation function:
		a. malloc: to perform a memory allocation(doesnt initialise)
			ptr = (ptr_type)malloc(size_in_bytes);
		
		b. calloc: to create contiguous memory alloction(initialised with 0)
			ptr = (ptr_type)calloc(n,size_in_bytes);
		
		c. realloc: to re allocate memory
			ptr = (ptr_type)realloc(old_ptr,new_size);
		
		d. free: free the memory
			free(ptr);


*Storage Class
	1. automaic
		keyword: auto
		scope: local
		initialised value: garbage
		lifetime: till function ends

	2. External
		keyword: extern *we use extern to declare a var*
		scope: global
		initialised value: 0
		lifetime: throughout the program

	3. Static
		keyword: static
		scope: local
		initialised value: 0
		lifetime: throughout the program
	
	4. Register
		keyword: register
		scope: local
		initialised value: garbage
		lifetime: till the functions ends

*declaration: to tell compiler about var_name and var_type and no space reserved
*definition: to tell compiler about var_name and var_type and space reserved
	
*Random variable Generator
	-providing seeed:
		srand(time(NULL));
		rand();

	-providing upper value
		rand()%upper_value;
	
	-providing upper and lower value
		rand()%(upper-lower+1)+lower

*FILE I/O
	>functions
		1. fopen("file_name","mode"); //returns file pointer
		2. fclose(file_pointer);
		3. fprintf(file_pointer,"content with specifiers",variables_for_specifiers);
		4. fscanf(file_pointer,"content with specifiers",variables_for_specifiers);
		5. fgetc(file_ptr);//stdin incase of terminal input
		6. fgets(string_name,n(size),file_ptr);//stdin incase of terminal input
		7. fputc("char",file_ptr);//stdout incase of terminal output
		8. fputs("string",file_ptr);//stdout incase of terminal output

	>Modes
		w  -->write in a file from scratch(new file created if not exist)
		r  -->read a file
		a  -->new content will be added to the file
		w+ -->first erase all content then write(scratch) and read a file (new file created if not exist)
		r+ -->write and read a file (data will be erase as much as it require to)
		a+ --> read from beginning but new content will add to the file

*Command Line Arguments
	int main(int argc,char* argv[]){
		//here argc is no. of Arguments
		//and argv is array of pointers pointing to that Arguments
		//argv[0] is file name
	}

*Function pointers
	int(*fptr)(int)(int);
	//declaring a function pointer which takes two int as input and returns int

	fptr=func1; //passing address of func1 to pointer

	fptr(4,5); //using pointer instead of function name